/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package net.reusinthewheel.reusingthewheelKotlin

import com.vladsch.flexmark.ext.yaml.front.matter.AbstractYamlFrontMatterVisitor
import com.vladsch.flexmark.ext.yaml.front.matter.YamlFrontMatterExtension
import com.vladsch.flexmark.html.HtmlRenderer
import com.vladsch.flexmark.parser.Parser
import com.vladsch.flexmark.util.ast.Node
import com.vladsch.flexmark.util.data.MutableDataSet
import java.io.File
import java.net.URL
import java.nio.file.Path
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import java.util.*
import kotlin.Comparator
import kotlin.io.path.Path
import kotlin.io.path.createDirectories

fun main() {
    val parser = ContentParser()

    val website = Website(
        "Reusing the wheel",
        URL("https://reusingthewheel.net"),
        "A blog about programming and my other hobbies",
        "Piotr Rusin",
        listOf()
    )

    val allContent = File("content").walkBottomUp()
        .filter { it.path.endsWith(".md") }
        .map {
            parser.parseContent(it, website)
        }.toList()

    println("DONE!")
}

data class Link(val url: URL, val title: String)

class Website(
    val title: String,
    val baseUrl: URL,
    val description: String,
    val author: String,
    val menuItems: List<String>,
    ) {

    private val pages = mutableMapOf<String, PageConfig>()

    fun addPage(page: PageConfig) {
        if (pages.containsKey(page.title)) {
            error("Can add page ${page.title} (path: ${page.path}) - " +
                    "page ${page.title} (path: ${pages[page.title]!!.path} already exists")
        }
        pages[page.title] = page
    }

    fun getPagesGroupedByYearAndSortedByDate(filter: (page: PageConfig) -> Boolean): SortedMap<Int?, List<PageConfig>> {
        return pages.values.filter(filter)
            .sortedByDescending { it.date }
            .groupBy { it.date?.year }
            .toSortedMap(Comparator.naturalOrder<Int>().reversed())
    }

    fun getPosts(): SortedMap<Int?, List<PageConfig>> {
        return getPagesGroupedByYearAndSortedByDate { it.path.startsWith("/posts") }
    }

    fun getPagesByCategory(categoryName: String): SortedMap<Int?, List<PageConfig>> {
        return getPagesGroupedByYearAndSortedByDate { it.taxonomies.categories.contains(categoryName) }
    }

    fun getPagesByProject(projectName: String): SortedMap<Int?, List<PageConfig>> {
        return getPagesGroupedByYearAndSortedByDate { it.taxonomies.projects.contains(projectName) }
    }

    fun getCategoryLink(categoryName: String): Link {
        return Link(
            baseUrl.extendWithPath(Path.of("categories/$categoryName")),
            categoryName
        )
    }

    fun getProjectLink(projectName: String): Link {
        return Link(
            baseUrl.extendWithPath(Path.of("projects/$projectName")),
            projectName
        )
    }

}

fun URL.extendWithPath(path: Path): URL {
    return URL(this.protocol, this.host, this.port, Path.of("/", this.path, path.toString()).toString())
}


data class Taxonomies(val categories: Set<String>, val projects: Set<String>)

class PageConfig(
    val title: String,
    val path: Path,
    val date: LocalDateTime?,
    val taxonomies: Taxonomies,
    val website: Website
) {
    init {
        website.addPage(this)
    }
    fun geUrl(): URL {
        return URL(
            website.baseUrl.protocol,
            website.baseUrl.host,
            website.baseUrl.port,
            Path.of(website.baseUrl.path, path.toString()).toString()
        )
    }

    fun getCategoryLinks(): List<Link> {
        return taxonomies.categories.map { website.getCategoryLink(it) }
            .sortedBy { it.title }
    }

    fun getProjectLinks(): List<Link> {
        return taxonomies.projects.map { website.getCategoryLink(it) }
            .sortedBy { it.title }
    }

    fun getIsoDate(): String? {
        return date?.format(DateTimeFormatter.ISO_DATE_TIME)
    }
}

class ContentParser() {
    private val options = getMarkdownOptions()
    private val parser = Parser.builder(options).build()
    private val renderer = HtmlRenderer.builder(options).build()
    private val frontMatterVisitor = AbstractYamlFrontMatterVisitor()

    private fun getMarkdownOptions(): MutableDataSet {
        val options = MutableDataSet()
        options.set(Parser.EXTENSIONS, listOf(YamlFrontMatterExtension.create()));
        return options
    }

    fun parseContent(file: File, website: Website): PageConfig {
        val document = parser.parse(file.readText(Charsets.UTF_8))
        frontMatterVisitor.visit(document)

        val taxonomies = Taxonomies(
            frontMatterVisitor.data["categories"]?.toSet() ?: setOf(),
            frontMatterVisitor.data["projects"]?.toSet() ?: setOf()
        )

        val pageConfig = PageConfig(
            frontMatterVisitor.data["title"]?.get(0) ?: error("Missing title"),
            Path.of(file.path.removePrefix("content").removeSuffix(".md")),
            getDate(frontMatterVisitor.data["date"]?.get(0)),
            taxonomies,
            website
        )

        saveContentToFile(document, pageConfig.path)

        return pageConfig
    }

    private fun getDate(value: String?): LocalDateTime? {
        if (value != null) {
            val pattern = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm")
            return LocalDateTime.parse(value, pattern)
        }
        return null
    }

    private fun saveContentToFile(document: Node, path: Path) {
        val html = renderer.render(document)
        val fullPath = Path("public").resolve("./$path/index.html")
        fullPath.parent.createDirectories()
        File(fullPath.toUri()).writeText(html)
    }
}
