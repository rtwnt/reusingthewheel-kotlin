/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package net.reusinthewheel.reusingthewheelKotlin

import com.vladsch.flexmark.ext.yaml.front.matter.AbstractYamlFrontMatterVisitor
import com.vladsch.flexmark.ext.yaml.front.matter.YamlFrontMatterExtension
import com.vladsch.flexmark.html.HtmlRenderer
import com.vladsch.flexmark.parser.Parser
import com.vladsch.flexmark.util.data.MutableDataSet
import java.io.File
import java.net.URL
import java.nio.file.Path
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import java.util.*
import kotlin.Comparator

class Section private constructor(
    val name: String,
    val sectionConfig: PageConfig?,
    val parent: Section?,
    val children: Set<Section>,
    val content: Set<PageConfig>
    ) {

    fun depthFirstWalk(visit: (s: Section) -> Unit) {
        visit(this)
        children.forEach { it.depthFirstWalk(visit) }
    }

    data class Builder(
        var name: String? = null,
        var sectionConfig: PageConfig? = null,
        var parent: Section? = null,
        var children: MutableSet<Section> = mutableSetOf(),
        var content: MutableSet<PageConfig> = mutableSetOf()
    ) {
        fun name(name: String) = apply { this.name = name }
        fun sectionConfig(sectionConfig: PageConfig) = apply { this.sectionConfig = sectionConfig }
        fun parent(sectionConfig: PageConfig) = apply { this.sectionConfig = sectionConfig }
        fun addChild(child: Section) = apply { children.add(child) }
        fun addContent(pageConfig: PageConfig) = apply { content.add(pageConfig) }

        fun build() = Section(name!!, sectionConfig, parent, children, content)
    }

}

class PageConfigCollector(val dotSeparatedPath: String) {
    private val path: MutableList<String> = dotSeparatedPath.split('.').toMutableList()
    val pages = mutableListOf<PageConfig>()

    fun getCollectedPages(): List<PageConfig> {
        return pages.toList()
    }

    fun collectPagesUnderPath(section: Section) {
        if (path.isEmpty()) {
            section.depthFirstWalk { collectPages(it) }
        } else {
            val segment = path.removeFirst()
            if (section.children.none { it.name == segment }) {
                error("Incorrect path")
            }
            val nextSection = section.children.first { it.name ==  segment}
            nextSection.depthFirstWalk { collectPagesUnderPath(it) }
        }
    }

    fun collectPages(section: Section) {
        pages.addAll(section.content)
        section.children.forEach { child -> child.depthFirstWalk { collectPages(it) } }
    }
}

fun main() {
    val websiteContentParser = WebsiteContentBuilder()

    val website = Website(
        "Reusing the wheel",
        URL("https://reusingthewheel.net"),
        "A blog about programming and my other hobbies",
        "Piotr Rusin",
        listOf()
    )

    File("content").walkTopDown()
        .onEnter { websiteContentParser.startSection(it) }
        .onLeave { websiteContentParser.finishSection(it) }
        .forEach {
            if (!it.isDirectory) {
                println(it.canonicalPath)
                try {
                    websiteContentParser.addContent(it, website)
                } catch (e: Exception) {
                    println("Error: ${e.message}. Skipping file ${it.path}")
                }
            }
        }

    website.addContent(websiteContentParser.rootSection)

    println("DONE!")
}

data class Link(val url: URL, val title: String)

class Website(
    val title: String,
    val baseUrl: URL,
    val description: String,
    val author: String,
    val menuItems: List<String>,
    ) {

    private val pages = mutableMapOf<String, PageConfig>()
    private lateinit var content: Section
    private val taxonomyTerms = mutableMapOf<TaxonomyType, MutableSet<TaxonomyTerm>>()

    fun getPages(): Map<String, PageConfig> {
        return pages.toMap()
    }

    fun getTaxonomyTerms(): Map<TaxonomyType, Set<TaxonomyTerm>> {
        return taxonomyTerms.entries.associate { it.key to it.value.toSet() }
    }

    fun addContent(content: Section) {
        this.content = content
        content.depthFirstWalk { section ->
            section.content.flatMap { it.taxonomyTerms }
                .forEach { taxonomyTerms.getOrPut(it.type, ::mutableSetOf).add(it) }
        }
    }

    fun getPosts(path: String): SortedMap<Int?, List<PageConfig>> {
        val collector = PageConfigCollector(path)
        content.depthFirstWalk { collector.collectPagesUnderPath(it) }
        return collector.getCollectedPages()
            .sortedByDescending { it.date }
            .groupBy { it.date?.year }
            .toSortedMap(Comparator.naturalOrder<Int>().reversed())
    }

    fun getTaxonomyLink(taxonomyTerm: TaxonomyTerm): Link {
        return Link(
            baseUrl.extendWithPath(taxonomyTerm.getPath()),
            taxonomyTerm.value
        )
    }
}

fun URL.extendWithPath(path: Path): URL {
    return URL(this.protocol, this.host, this.port, Path.of("/", this.path, path.toString()).toString())
}

enum class TaxonomyType(val plural: String) {
    CATEGORY("categories"),
    PROJECT("projects");
}

class TaxonomyTerm(val value: String, val type: TaxonomyType) {
    private val pages = mutableSetOf<PageConfig>()

    fun addPage(pageConfig: PageConfig) {
        pages.add(pageConfig)
    }

    fun getPages(): Set<PageConfig> {
        return pages.toSet()
    }

    fun getPath(): Path {
        return Path.of("${type.plural}/${value.lowercase().replace(' ', '-')}")
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as TaxonomyTerm

        if (value != other.value) return false
        if (type != other.type) return false

        return true
    }

    override fun hashCode(): Int {
        var result = value.hashCode()
        result = 31 * result + type.hashCode()
        return result
    }
}

class PageConfig(
    val title: String,
    val path: Path,
    val date: LocalDateTime?,
    val taxonomyTerms: Set<TaxonomyTerm>,
    val content: String,
    val website: Website
) {
    init {
        taxonomyTerms.forEach { it.addPage(this) }
    }
    fun getUrl(): URL {
        return URL(
            website.baseUrl.protocol,
            website.baseUrl.host,
            website.baseUrl.port,
            Path.of(website.baseUrl.path, path.toString()).toString()
        )
    }

    fun getTaxonomyLinksByType(type: TaxonomyType): List<Link> {
        return taxonomyTerms.filter { it.type == type }.map { website.getTaxonomyLink(it) }
    }

    fun getIsoDate(): String? {
        return date?.format(DateTimeFormatter.ISO_DATE_TIME)
    }
}

class WebsiteContentBuilder {
    private val markdownContentParser = MarkdownContentParser()

    private val sectionBuilders = mutableListOf<Section.Builder>()
    private val taxonomyTermCache = mutableMapOf<Pair<TaxonomyType, String>, TaxonomyTerm>()
    lateinit var rootSection: Section

    private fun getOrCreateTaxonomyTerm(value: String, type: TaxonomyType): TaxonomyTerm {
        return taxonomyTermCache.getOrPut(Pair(type, value)) { TaxonomyTerm(value, type) }
    }

    fun toPageConfig(path: String, markdownContent: MarkdownContent, website: Website): PageConfig {
        val taxonomiesForPage = TaxonomyType.values()
            .flatMap { type ->
                markdownContent.frontMatter[type.plural]
                    ?.map {getOrCreateTaxonomyTerm(it, type)} ?: setOf()
            }.toSet()

        val title = markdownContent.frontMatter["title"]?.get(0) ?: error("Missing title")

        return PageConfig(
            title,
            Path.of(path.removePrefix("content").removeSuffix(".md")),
            getDate(markdownContent.frontMatter["date"]?.get(0)),
            taxonomiesForPage,
            markdownContent.renderedHtml,
            website
        )
    }

    private fun getDate(value: String?): LocalDateTime? {
        if (value != null) {
            val pattern = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm")
            return LocalDateTime.parse(value, pattern)
        }
        return null
    }

    fun startSection(file: File): Boolean {
        val builder = Section.Builder().name(file.name)
        sectionBuilders.add(builder)
        return true
    }

    fun addContent(file: File, website: Website) {
        if (sectionBuilders.isEmpty()) {
            error("Missing section for ${file.path}")
        }
        val markdownContent = markdownContentParser.parseContent(file)
        val pageConfig = toPageConfig(file.path, markdownContent, website)
        if (file.name == "_index.md") {
            sectionBuilders.last().sectionConfig(pageConfig)
            return
        }
        sectionBuilders.last().addContent(pageConfig)
    }

    fun finishSection(file: File): Boolean {
        if (sectionBuilders.isEmpty()) {
            error("No section to process")
        }
        val finishedSection = sectionBuilders.removeLast().build()
        if (sectionBuilders.isEmpty()) {
            rootSection = finishedSection
        } else {
            sectionBuilders.last().addChild(finishedSection)
        }
        return true
    }
}

data class MarkdownContent(val frontMatter: Map<String, List<String>>, val renderedHtml: String)

class MarkdownContentParser() {
    private val options = getMarkdownOptions()
    private val parser = Parser.builder(options).build()
    private val renderer = HtmlRenderer.builder(options).build()

    private fun getMarkdownOptions(): MutableDataSet {
        val options = MutableDataSet()
        options.set(Parser.EXTENSIONS, listOf(YamlFrontMatterExtension.create()))
        return options
    }

    fun parseContent(file: File): MarkdownContent {
        val markdownDocument = parser.parse(file.readText(Charsets.UTF_8))
        val frontMatterVisitor = AbstractYamlFrontMatterVisitor()
        frontMatterVisitor.visit(markdownDocument)

        return MarkdownContent(
            frontMatterVisitor.data,
            renderer.render(markdownDocument)
        )
    }
}
